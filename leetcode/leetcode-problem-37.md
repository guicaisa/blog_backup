---
title: leetcode problem 37. 解数独
tags: 算法
categories:
  - leetcode
  - leetcode 0001-0050
abbrlink: 6441ee2e
date: 2021-06-08 23:24:03
---

# <center>leetcode problem 37. 解数独</center>

## 链接

https://leetcode-cn.com/problems/sudoku-solver/



## 题目描述

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 \'.\' 表示。

 

示例：

![p37_1](leetcode-problem-37/p37_1.png)

输入: board = \[\[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"\],\[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"\],\[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"\],\[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"\],\[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"\],\[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"\],\[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"\],\[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"\],\[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"\]\]
输出: \[\[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"\],\[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"\],\[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"\],\[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"\],\[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"\],\[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"\],\[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"\],\[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"\],\[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"\]\]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：

![p37_2](leetcode-problem-37/p37_2.png)


提示：

board.length == 9
board\[i\].length == 9
board\[i\]\[j\] 是一位数字或者 \'.\'
题目数据 保证 输入数独仅有一个解



## 解法

### 1.

事先将已经存在的值相关的行，列，九宫格的部分进行设置，然后先找到一个为\'.\'索引位置为开始，进行递归操作，遍历\'1\' - \'9\'，判断是否在同行，同列，同九宫格中存在该值，如果没有的话，将相关索引位置以及行，列，九宫格中的相关值进行设置，从下一个是\'.\'的位置开始继续上述的判断操作。如果向下展开的递归操作失败，说明当前这个节点的值选择的有问题，将当前选择的值的相关行，列，九宫格中的值重置，继续遍历\'1\' - \'9\'中剩下的可选值，直到向下展开的递归操作成功，返回结果。

#### 代码

```c++
class Solution 
{
public:
    void SolveSudoku(std::vector<std::vector<char>>& board)
    {
        int vr[9][9] = { 0 };
        int vc[9][9] = { 0 };
        int vs[9][9] = { 0 };

        int x = 0;
        int y = 0;
        int first = 0;

        for (int i = 0; i < board.size(); ++i)
        {
            for (int j = 0; j < board[i].size(); ++j)
            {
                if (board[i][j] != '.')
                {
                    int t = board[i][j] - '0' - 1;
                    int n = (i / 3 * 3) + (j / 3);

                    vr[i][t] = vc[j][t] = vs[n][t] = 1;
                }
                else
                {
                    if (first == 0)
                    {
                        first = 1;
                        x = i;
                        y = j;
                    }
                }
            }
        }

        Recursive(board, vr, vc, vs, x, y);
    }

    bool Recursive(std::vector<std::vector<char> >& board, int(*vr)[9], int(*vc)[9], int(*vs)[9], int x, int y)
    {
        int n = (x / 3 * 3) + (y / 3);

        for (char i = '1'; i <= '9'; ++i)
        {
            int t = i - '0' - 1;
            if (vr[x][t] == 0 && vc[y][t] == 0 && vs[n][t] == 0)
            {
                vr[x][t] = vc[y][t] = vs[n][t] = 1;
                board[x][y] = i;

                int n_x = 0;
                int n_y = 0;
                int first = 0;

                for (int i = y == 8 ? x + 1 : x; i < board.size(); ++i)
                {
                    for (int j = i == x ? y + 1 : 0; j < board[i].size(); ++j)
                    {
                        if (board[i][j] == '.')
                        {
                            first = 1;
                            n_x = i;
                            n_y = j;
                            break;
                        }
                    }

                    if (first == 1)
                    {
                        break;
                    }
                }

                if (n_x == 0 && n_y == 0)
                {
                    return true;
                }

                bool flag = Recursive(board, vr, vc, vs, n_x, n_y);

                if (flag)
                {
                    return true;
                }

                vr[x][t] = vc[y][t] = vs[n][t] = 0;
                board[x][y] = '.';
            }
        }

        return false;
    }
};
```

